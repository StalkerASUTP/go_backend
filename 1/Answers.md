### 1. Что такое goroutine в Go и как она отличается от традиционного потока?
Горутины представляют собой легковесные процессы, которыми распоряжается среда выполнения языка Go. При запуске Go-программы среда выполнения языка Go создает для ее выполнения несколько потоков и запускает одну горутину.\
Создание горутины занимает меньше времени, чем создание потока, поскольку при этом не создается системный ресурс. Исходный размер стека горутин меньше размера стека потоков (~2KB) и может быть увеличен по мере необходимости. Переключение между горутинами занимает меньше времени, чем переключение между потоками, поскольку осуществляется полностью внутри процесса, не используются системные вызовы.Планировщик может оптимизировать свои решения, поскольку он является составной частью Go-процесса. Планировщик выявляет те случаи, когда следует отменить выполнение горутины, чтобы она не блокировала ввод-вывод. Он также следит за тем, чтобы работа была равномерно распределенамежду потоками операционной системы, выделенными для вашего Go-процесса.
Благодаря этому можно создавать сотни, тысячи и даже десятки тысяч одновременных горутин. Горутина запускается путем размещения ключевого слова go перед вызовом функции.В качестве горутины можно запустить любую функцию.
### 2. Что такое каналы в Go? Что будет возвращено при чтении из закрытого канала?
Горутины общаются друг с другом посредством каналов. Подобно срезам и картам, каналы представляют собой встроенный тип, экземпляры которого создаются с помощью функции make:
```
ch := make(chan int)
```
Как и карты, каналы представляют собой ссылочный тип. Нулевым значением для каналов является значение nil.
```
a := <-ch // считывает значение из канала ch
ch <- b // записывает значение b в канал сh
```
По умолчанию каналы являются небуферизованными. После каждой операции записи в такой открытый канал он блокируется до тех пор, пока другая горутина не считает данные из этого канала. С записью такая же ситуация. Буферизированный канал не блокируется пока его буфер не заполнится. При заполнии блокируется до тех пор пока не будет произведено чтение из канала. Блокировка также произойдет при попытке чтения из канала с пустым буфером.
После завершения записи в канал его следует закрыть с помощью встроенной функции _close()_. Задача закрытия канала возлагается на ту горутину, которая производит запись в канал.
Для проверки закрыт ли канал используется идиома «запятая-ok»:
```
v, ok := <-ch
```
Если переменной ok будет присвоено значение true, значит, канал открыт, при false, канал закрыт.\
Если канал является буферизованным и в нем еще есть непрочитанные значения, то они будут возвращены в последовательном порядке. Если канал является небуферизованным или буферизованным, но уже без каких-либо значений, то будет возвращено нулевое значение для используемого каналом типа
### 3. Как в Go реализовать взаимное исключение при доступе к общим ресурсам?
#### Основные способы:
sync.Mutex — базовый мьютекс для блокировки критических секций
Он обладает методами Lock и Unlock.Вызов метода Lock приостанавливает выполнение текущей горутины, если критическая секция в данный момент занята другой горутиной. Если критическая секция свободна, текущая горутина устанавливает блокировку и выполняет код в критической секции. Вызов метода Unlock в экземпляре типа Mutex завершает использование критической секции.\
sync.RWMutex — читатель-писатель мьютекс (множественное чтение, эксклюзивная запись)
С помощью методов Lock и Unlock осуществляется управление блокировкой
на запись, а с помощью методов RLock и RUnlock — управление блокировкой
на чтение.\
Каналы — можно использовать буферизованный канал размером 1.\
Атомарные операции из пакета sync/atomic
### 4. Что такое анонимная функция в Go?
Анонимная функция — это функция без имени,которая может быть определена и вызвана на месте, присвоена переменной или передана как аргумент. Анонимная функция объявляется с помощью ключевого слова func, за которым следуют входные параметры, возвращаемые значения и открывающая фигурная скобка. Как и любая другая функция, анонимная функция вызывается с помощью круглых скобок. Функции, объявляемые внутри других функций, представляют собой особую разновидность функций, называемую замыканиями, которые могут
использовать и изменять переменные, объявленные во внешней функции. Также можно передавать анонимные функции в качестве параметров в функции высшего порядка, например: _sort.Slice()_, функции также могут возвращать другие функции.
### 5. Как в Go обрабатывать паники и ошибки?
Обработка ошибок в Go сводится к возвращению значения типа error в качестве последнего возвращаемого значения функции. Когда функция выполняется ожидаемым образом, в качестве параметра ошибки возвращается значение nil. Если что-то идет не так, вместо этого возвращается значение ошибки. После этого вызывающая функция проверяет возвращаемое значение ошибки путем сравнения его со значением nil и обрабатывает ошибку или возвращает некоторую собственную ошибку.\
Go предоставляет возможность перехватить панику, чтобы обеспечить мягкое прекращение работы или вообще обойтись без него. Для этого встроенная функция recover вызывается внутри оператора defer, чтобы проверить, была ли паника. При наличии паники возвращается присвоенное ей значение. После выполнения функции recover работа продолжается в обычной манере
### 6. Существует ли концепция наследования в Go?
На это можно дать очень простой ответ: в языке Go нет классов, потому что в нем нет наследования. В Go используется композиция через встраивание. Любые поля или методы, объявленные во встроенном поле, повышаются до содержащей его структуры и могут быть вызваны непосредственно в ней. Можно встроить в структуру любой тип, а не только другую структуру.Это позволяет повышать методы встроенного типа до содержащей его структуры. Если вмещающая структура имеет поля или методы с таким же именем, как у встроенного поля, то для обращения к этим затененным полям и методам следует использовать тип встроенного поля. 
### 7. Что такое интерфейсы в Go?
Интерфейс в Go — это тип, определяющий набор сигнатур методов. Это контракт, который описывает поведение.
Что делает интерфейсы языка Go особенными, так это то, что они реализуются неявным образом. Конкретный тип не объявляет о том, что он реализует интерфейс. Если набор методов конкретного типа содержит все методы из набора методов интерфейса, то этот конкретный тип реализует интерфейс. Это означает, что этот конкретный тип может быть присвоен переменной или полю, в качестве типа которого указан данный интерфейс. Это способствует обеспечению типобезопасности в сочетании с низкой связанностью.«Программируйте на уровне интерфейса, а не на уровне реализации». В таком случае вы будете зависеть только от поведения, а не от реализации, что позволит при необходимости заменить одну реализацию на другую.
### 8. Что такое "грязное чтение" (dirty read) в контексте баз данных?
Грязное чтение (Dirty Read) — это ситуация в системах управления базами данных, когда одна транзакция читает данные, которые были изменены другой незавершенной (uncommitted) транзакцией, и эти изменения могут быть в дальнейшем отменены (rollback). Для предотварщения нужно использовать соответсвующие уровни изоляции READ COMMITED для предотвращения грязного чтения, использование блокировок.













